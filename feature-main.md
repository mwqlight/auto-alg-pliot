# 算法驾驶舱平台开发ß

## 项目概述
开发一个高科技风格的算法驾驶舱平台，全面展示各类算法的实现原理、执行过程和性能特性。该平台需按照算法分类组织内容，提供代码演示、动态可视化执行过程、时间/空间复杂度分析等功能，为学习者提供直观、深入的算法理解体验。

## 技术要求
- **后端**: Spring Boot 3.x + MyBatis-Plus + Redis (缓存)
- **前端**: Vue3 + TypeScript + Pinia + Vite + Element Plus + ECharts
- **数据库**: MySQL 8.0
- **部署**: Docker容器化部署
- **API规范**: RESTful API设计，统一响应格式
- **界面风格**: 深色高科技风格，带有动态背景、粒子效果、霓虹元素等视觉效果

## 系统架构
1. **后端模块**：
   - 算法分类管理模块
   - 算法内容管理模块（代码、说明、复杂度分析）
   - 算法执行引擎（支持安全的代码执行和结果返回）
   - 用户行为记录模块
   - 数据统计分析模块

2. **前端模块**：
   - 全局导航与驾驶舱视图
   - 算法分类展示模块
   - 算法详情展示模块
   - 代码编辑与执行模块
   - 动态可视化模块
   - 复杂度分析图表模块
   - 个人学习中心

## 算法分类要求（必须包含以下全部类别）

### 1. 排序算法
- 冒泡排序
- 选择排序
- 插入排序
- 希尔排序
- 归并排序
- 快速排序
- 堆排序
- 计数排序
- 桶排序
- 基数排序
- Timsort

### 2. 搜索算法
- 线性搜索
- 二分搜索
- 插值搜索
- 跳跃搜索
- 指数搜索
- 斐波那契搜索
- 哈希搜索
- 二叉搜索树
- B/B+树
- R树

### 3. 图论算法
- 深度优先搜索(DFS)
- 广度优先搜索(BFS)
- Dijkstra最短路径
- Bellman-Ford算法
- Floyd-Warshall算法
- Prim最小生成树
- Kruskal最小生成树
- 拓扑排序
- 强连通分量
- 最大流算法(Edmonds-Karp, Dinic)
- 二分图匹配
- A*寻路算法
- Tarjan算法

### 4. 动态规划
- 背包问题(0/1, 完全, 多重)
- 最长公共子序列(LCS)
- 最长递增子序列(LIS)
- 编辑距离
- 矩阵链乘法
- 最优二叉搜索树
- Floyd-Warshall(动态规划版)
- 硬币找零问题
- 最大子数组和
- 股票买卖问题

### 5. 贪心算法
- 活动选择问题
- 霍夫曼编码
- Dijkstra最短路径(贪心版)
- Prim最小生成树
- 分数背包问题
- 任务调度问题
- 集合覆盖问题
- 最小生成树

### 6. 分治算法
- 归并排序
- 快速排序
- 二分搜索
- 汉诺塔问题
- 大整数乘法
- 矩阵乘法(Strassen)
- 最近点对问题
- 线段树

### 7. 回溯算法
- 八皇后问题
- N皇后问题
- 图着色问题
- 哈密顿回路
- 子集和问题
- 0/1背包问题(回溯版)
- 数独求解
- 全排列
- 组合问题
- 括号生成

### 8. 特殊算法
- KMP字符串匹配
- Rabin-Karp算法
- Boyer-Moore算法
- 后缀数组/后缀树
- BWT变换(Burrows-Wheeler)
- 位运算技巧
- 快速幂
- 模逆元
- 欧几里得算法
- 扩展欧几里得算法
- 约瑟夫问题
- 蒙特卡罗算法
- 拉斯维加斯算法

### 9. 数学算法
- 素数筛法(埃氏筛, 欧拉筛)
- 快速幂
- 矩阵快速幂
- 高精度计算
- 高斯消元
- FFT(快速傅里叶变换)
- 离散对数
- 中国剩余定理
- 模逆元
- 组合数学算法
- 博弈论基础算法

### 10. 机器学习/大模型基础算法
- 线性回归
- 逻辑回归
- K-means聚类
- 决策树
- 朴素贝叶斯
- 支持向量机(SVM)
- 神经网络基础
- 反向传播
- Word2Vec
- Transformer基础原理
- 注意力机制
- 梯度下降优化算法

### 11. 数据结构相关算法
- 数组与链表操作
- 栈与队列实现
- 哈希表冲突解决
- 二叉树遍历
- B/B+树操作
- 红黑树
- 并查集
- Trie树
- 跳表
- 布隆过滤器
- LRU缓存
- 线段树
- 树状数组(Fenwick Tree)

### 12. 实用算法
- 洗牌算法(Fisher-Yates)
- 随机数生成
- 均匀采样
- 一致性哈希
- 负载均衡算法
- 限流算法(令牌桶, 漏桶)
- 布隆过滤器
- 压缩算法基础
- CRC校验
- 正则表达式匹配引擎

## 每个算法必须包含的内容
1. **算法简介**：简明扼要介绍算法的用途、特点
2. **算法思想**：核心思想与解决思路
3. **代码实现**：
   - 提供至少一种主流语言实现(Java/Python/JavaScript)
   - 代码需有详细注释
   - 支持高亮显示
4. **动态演示**：
   - 可视化执行过程
   - 支持控制执行速度
   - 支持单步执行/暂停/重置
5. **复杂度分析**：
   - 时间复杂度(最好/平均/最坏情况)
   - 空间复杂度
   - 用图表直观展示不同数据规模下的性能对比
6. **应用场景**：算法在实际工程中的应用举例
7. **变种与优化**：算法的常见变种和优化思路
8. **思考题**：2-3个与算法相关的思考或练习题

## 界面设计要求
1. **整体风格**：
   - 深色主题，带有霓虹蓝/紫色点缀
   - 背景使用粒子效果或流动的代码/二进制数据流
   - 适度的动画过渡效果
   - 响应式设计，适配不同屏幕尺寸

2. **核心页面**：
   - **首页/驾驶舱**：全景算法分类导航，3D效果呈现各类算法关系，重要算法推荐
   - **算法分类页**：卡片式展示各类算法，支持筛选和排序
   - **算法详情页**：
     * 左侧：代码展示与编辑区(可修改参数执行)
     * 右侧上部：动态可视化区域
     * 右侧中部：复杂度分析图表
     * 右侧下部：算法说明与应用场景
   - **比较实验室**：支持同时比较2-4种算法在相同数据下的表现
   - **个人中心**：学习进度、收藏的算法、历史记录等

3. **交互细节**：
   - 代码区域支持修改参数后实时执行
   - 可视化区域支持调整数据规模、初始状态
   - 复杂度分析图表支持不同输入规模的性能对比
   - 提供"驾驶模式"一键演示算法执行全流程
   - 重要概念支持悬浮提示说明

## 后端API要求
1. **算法分类API**：
   - 获取所有算法分类
   - 获取指定分类下的所有算法

2. **算法内容API**：
   - 获取算法详情(含代码、说明、复杂度等)
   - 获取算法演示数据
   - 执行算法代码(沙箱环境)

3. **用户行为API**：
   - 记录用户学习进度
   - 收藏/取消收藏算法
   - 记录算法执行历史

4. **系统API**：
   - 用户认证
   - 系统配置获取
   - 反馈提交

## 数据库设计要求
- 算法分类表(algorithm_category)
- 算法信息表(algorithm)
- 算法代码表(algorithm_code)
- 算法复杂度表(algorithm_complexity)
- 演示数据表(demo_data)
- 用户表(user)
- 用户学习记录表(learning_record)
- 收藏表(collection)

## 安全要求
1. 代码执行必须在安全沙箱环境中进行
2. 限制执行时间和内存使用
3. 禁止访问系统资源和网络
4. 前后端数据交互必须进行验证
5. 防止XSS和CSRF攻击

## 部署要求
1. 提供Dockerfile和docker-compose.yml文件
2. 支持一键部署
3. 包含必要的环境变量配置说明
4. 提供API文档(Swagger)

## 交付物
1. 完整的源代码
2. 详细的README文档(包含运行、配置、部署指南)
3. 数据库初始化SQL脚本
4. API文档
5. 系统架构设计图
6. 界面设计稿

## 注意事项
1. 确保所有算法实现正确无误，经过充分测试
2. 前端可视化效果要流畅，数据规模较大时要有优化
3. 代码注释要详尽，特别是复杂的算法部分
4. 响应式设计必须保证在桌面、平板和手机上都有良好体验
5. 保持高性能，避免在展示复杂算法时出现卡顿

## 验收标准
1. 包含提示中列出的所有算法分类和具体算法
2. 每个算法都具有完整的代码演示、动态可视化、复杂度分析
3. 界面具有高科技风格，交互流畅
4. 系统稳定，能够处理大量用户并发访问
5. 代码结构清晰，有完善的注释
6. 完整的部署文档，能够顺利部署运行

请严格按照以上要求实现此算法驾驶舱平台，确保内容全面、界面美观、功能完善、性能优良。